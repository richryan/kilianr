---
title: "inference-with-moving-block-bootstrap"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{inference-with-moving-block-bootstrap}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: references.bib  
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(kilianr)
```

To render the vignette:
devtools::build_rmd("vignettes/my-vignette.Rmd")

# Introduction

The procedure is discussed by @kilian_lutkepohl_2017 on
pages 355--356 in chapter 12, "Inference."

The mechanics of the moving block boostrap can be seen
by looking at how the error matrix is constructed.



```{r}
junk <- readLines("references.bib")
writeLines(junk, "junk.bib")
```


The data are fit to the VAR($p$) model
$$
y_t = \nu + A_1 y_{t-1} + \cdots + A_p y_{t-p} + u_t,
$$
where $u_t$ is serially uncorrelated but **conditionally heteroskedastic**.
After estimating the model parameters,
the estimated model residuals are computed as
$$
 \widehat{u}_t = y_t - \widehat{\nu} - \widehat{A}_1 y_{t-1} - \cdots - \widehat{A}_p y_{t-p} \text{ for } t=1,\dots,T.
$$

The aim is resampling the estimated residuals.
A block of length $l < T$ is chosen.
The number of blocks is $s = \lceil T / l \rceil$
where $s$ denotes the smallest integer larger or equal to $T / l$ so that
$s \geq T / l$ or $sl \geq T$.
The last inequality says that number of blocks times the length of each block is greater than $T$.

"Bootstrap innovations are generated by drawing $s$ time with replacement
from the rows" of the matrix
$$
\begin{bmatrix}
\widehat{u}_1 & \widehat{u}_2 & \dots & \widehat{u}_l \\
\widehat{u}_2 & \widehat{u}_3 & \dots & \widehat{u}_{1+l} \\
\vdots        & \vdots        & \vdots& \vdots \\
\widehat{u}_{T-l+1} & \widehat{u}_{T-l+2} & \dots & \widehat{u}_{T} \\
\end{bmatrix}
$$
The blocks are concatenated and the first $T$ boostrap innovations are kept.
*Note*: the boostrap-innovation draws must be recentered so that
$E \left[ u_t^* \right] = 0$ for all $t=1,\dots,T$.

The bootstrap sample $\left[ y_{-p+1}^*,\dots,y_{T}^*\right]$ is generated
recursively using
$$
y_t^* = \widehat{\nu} + \widehat{A}_1 y_{t-1}^* + \cdots + \widehat{A}_p y_{t-p}^*.
$$

# Mechanics of moving block bootstrap in R

The series of 

```{r}
library(dplyr)
# Create data to look through
yview <- kilianLutkepohlCh12Figure12_5 |> 
  mutate(date_prefix = paste0(lubridate::year(date), "-", format(date, "%m")),
         oil_supply = paste0(date_prefix, "-", "oilsupply"),
         agg_demand = paste0(date_prefix, "-", "aggdemand"),
         rpoil = paste0(date_prefix, "-", "rpoil")) |> 
  select(oil_supply, agg_demand, rpoil)


t_yview <- nrow(yview)
p_yview <- 3
q_yview <- 3

y <- t(yview)
Y <- y[, p_yview:t_yview]
for (i in 1:(p_yview - 1)) {
  Y <- rbind(Y, y[, (p_yview - i):(t_yview - i)])
}
Y

Uhat <- y

rUtilde <- matrix(0, nrow = q_yview * p_yview, ncol = t_yview - p_yview)
rY <- matrix(0, q_yview * p_yview, t_yview - p_yview + 1)
len <- 4
pos <- runif(1, min = 0, max = 1) * (t_yview - p_yview + 1) + 1
rY[, 1] <- Y[, pos]

upos <- ceiling(runif(1) * ((t_yview - p_yview) - len + 1))
# rUtilde[, 1:len] <- Uhat[,upos:(upos + len - 1)]
rUtilde <- Uhat[,upos:(upos + len - 1)]

for (k in 1:ceiling((t_yview - p_yview) / len)) {
  upos <- ceiling(runif(1) * ((t_yview - p_yview) - len + 1))
  print(upos)
  rUtilde <- cbind(rUtilde, Uhat[, upos:(upos + len - 1)])
}
```

# Application: global market for crude oil

# References
